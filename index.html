<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Node-ipc : Inter Process Communication Module for node using Unix sockets and servers. Giving lightning speed by bypassing the network card for local sockets and ipc." />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Node-ipc</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/RIAEvangelist/node-ipc">View on GitHub</a>

          <h1 id="project_title">Node-ipc</h1>
          <h2 id="project_tagline">Inter Process Communication Module for node using Unix sockets and servers. Giving lightning speed by bypassing the network card for local sockets and ipc.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/RIAEvangelist/node-ipc/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/RIAEvangelist/node-ipc/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="node-ipc" class="anchor" href="#node-ipc"><span class="octicon octicon-link"></span></a>node-ipc</h1>

<p><em>a nodejs module for local and remote Inter Process Communication</em></p>

<p><strong>npm install node-ipc</strong></p>

<p><em>this is a new project so more documentation will come</em></p>

<hr><h4>
<a name="types-of-ipc-sockets" class="anchor" href="#types-of-ipc-sockets"><span class="octicon octicon-link"></span></a>Types of IPC Sockets</h4>

<table>
<thead><tr>
<th>Type</th>
<th>Definition</th>
</tr></thead>
<tbody>
<tr>
<td>Unix Socket</td>
<td>Gives lightning fast communication and avoids the network card to reduce overhead and latency. <a href="https://github.com/RIAEvangelist/node-ipc/tree/master/example/unixSocket/" title="Unix Socket Node IPC examples">Local Unix Socket examples </a>
</td>
</tr>
<tr>
<td>TCP Socket</td>
<td>Gives the most reliable communication across the network. Can be used for local IPC as well, but is slower than #1's Unix Socket Implementation because TCP sockets go through the network card while Unix Sockets do not. <a href="https://github.com/RIAEvangelist/node-ipc/tree/master/example/TCPSocket/" title="TCP Socket Node IPC examples">Local or remote network TCP Socket examples </a>
</td>
</tr>
<tr>
<td>TLS Socket</td>
<td><strong><em>coming soon...</em></strong></td>
</tr>
<tr>
<td>UDP Sockets</td>
<td>Gives the <strong>fastest network communication</strong>. UDP is less reliable but much faster than TCP. It is best used for streaming non critical data like sound, video, or multiplayer game data as it can drop packets depending on network connectivity and other factors. UDP can be used for local IPC as well, but is slower than #1's Unix Socket Implementation because UDP sockets go through the network card while Unix Sockets do not. <a href="https://github.com/RIAEvangelist/node-ipc/tree/master/example/UDPSocket/" title="UDP Socket Node IPC examples">Local or remote network UDP Socket examples </a>
</td>
</tr>
</tbody>
</table><hr><h3>
<a name="ipc-default-variables" class="anchor" href="#ipc-default-variables"><span class="octicon octicon-link"></span></a>IPC Default Variables</h3>

<p><code>ipc.config</code>  </p>

<p>Set these variables in the <code>ipc.config</code> scope to overwrite or set default values.</p>

<pre><code>{
    appspace        : 'app.',
    socketRoot      : '/tmp/',
    id              : os.hostname(),
    networkHost     : 'localhost',
    networkPort     : 8000,
    encoding        : 'utf8',
    silent          : false,
    maxConnections  : 100,
    retry           : 500
}
</code></pre>

<table>
<thead><tr>
<th>variable</th>
<th>documentation</th>
</tr></thead>
<tbody>
<tr>
<td>appspace</td>
<td>used for Unix Socket (Unix Domain Socket) namespacing. If not set specifically, the Unix Domain Socket will combine the socketRoot, appspace, and id to form the Unix Socket Path for creation or binding. This is available incase you have many apps running on your system, you may have several sockets with the same id, but if you change the appspace, you will still have app specic unique sockets.</td>
</tr>
<tr>
<td>socketRoot</td>
<td>the directory in which to create or bind to a Unix Socket</td>
</tr>
<tr>
<td>id</td>
<td>the id of this socket or service</td>
</tr>
<tr>
<td>networkHost</td>
<td>the local or remote host on which TCP, TLS or UDP Sockets should connect</td>
</tr>
<tr>
<td>networkPort</td>
<td>the default port on which TCP, TLS, or UDP sockets should connect</td>
</tr>
<tr>
<td>encoding</td>
<td>the default encoding for data sent on sockets</td>
</tr>
<tr>
<td>silent</td>
<td>turn on/off logging default is false which means logging is on</td>
</tr>
<tr>
<td>maxConnections</td>
<td>this is the max number of connections allowed to a socket. It is currently only being set on Unix Sockets. Other Socket types are using the system defaults.</td>
</tr>
<tr>
<td>retry</td>
<td>this is the time in milliseconds a client will wait before trying to reconnect to a server if the connection is lost. This does not effect UDP sockets since they do not have a client server relationship like Unix Sockets and TCP Sockets.</td>
</tr>
</tbody>
</table><hr><h4>
<a name="ipc-methods" class="anchor" href="#ipc-methods"><span class="octicon octicon-link"></span></a>IPC Methods</h4>

<p>These methods are available in the IPC Scope.  </p>

<hr><h5>
<a name="log" class="anchor" href="#log"><span class="octicon octicon-link"></span></a>log</h5>

<p><code>ipc.log(a,b,c,d,e...);</code>  </p>

<p>ipc.log will accept any number of arguments and if <code>ipc.config.silent</code> is not set, it will concat them all with a sincle space ' ' between them and then log them to the console. This is fast because it prevents any concation from happening if the ipc is set to silent. That way if you leave your logging in place it should not effect performance.</p>

<p>the log also supports <a href="https://github.com/Marak/colors.js">colors</a> implementation. All of the available styles are supported and the theme styles are as follows :</p>

<pre><code>{
    good    : 'green',
    notice  : 'yellow',
    warn    : 'red',
    error   : 'redBG',
    debug   : 'magenta',
    variable: 'cyan',
    data    : 'blue'
}    
</code></pre>

<p>You can override any of these settings by requireing colors and setting the theme as follows :</p>

<pre><code>var colors=require('colors');

colors.setTheme(
    {
        good    : 'zebra',
        notice  : 'redBG',
        ...
    }    
);
</code></pre>

<hr><h5>
<a name="connectto" class="anchor" href="#connectto"><span class="octicon octicon-link"></span></a>connectTo</h5>

<p><code>ipc.connectTo(id,path,callback);</code>  </p>

<p>Used for connecting as a client to local Unix Sockets. <strong><em>This is the fastst way for processes on the same machine to communicate</em></strong> because it bypasses the network card which TCP and UDP must both use.</p>

<ol>
<li>
<code>id</code> <strong><em>required</em></strong> is the string id of the socket being connected to. The socket with this id is added to the ipc.of object when created.</li>
<li>
<code>path</code> <strong><em>optional</em></strong> is the path of the Unix Domain Socket File, if not set this will be defaylted to <code>ipc.config.socketRoot</code>+<code>ipc.config.appspace</code>+<code>id</code> </li>
<li>
<code>callback</code> <strong><em>optional</em></strong> this is the function to execute when the socket has been created.</li>
</ol><p><strong>examples</strong></p>

<pre><code>ipc.connectTo('world');
</code></pre>

<p>or using just an id and a callback</p>

<pre><code>ipc.connectTo(
    'world',
    function(){
        ipc.of.world.on(
            'hello',
            function(data){
                ipc.log(data.debug); 
                //if data was a string, it would have the color set to the debug style applied to it
            }
        )
    }
);
</code></pre>

<p>or explicitly setting the path</p>

<pre><code>ipc.connectTo(
    'world',
    'myapp.world'
);
</code></pre>

<p>or explicitly setting the path with callback</p>

<pre><code>ipc.connectTo(
    'world',
    'myapp.world',
    function(){
        ...
    }
);
</code></pre>

<hr><h5>
<a name="connecttonet" class="anchor" href="#connecttonet"><span class="octicon octicon-link"></span></a>connectToNet</h5>

<p><code>ipc.connectToNet(id,host,port,callback)</code>  </p>

<p>Used to connect as a client to a TCP or TLS socket via the network card. This can be local or remote, if local, it is recommended that you use the Unix Socket Implementaion of <code>connectTo</code> instead as it is much faster since it avoids the network card alltogether.</p>

<ol>
<li>
<code>id</code> <strong><em>required</em></strong> is the string id of the socket being connected to. For TCP &amp; TLS sockets, this id is added to the <code>ipc.of</code> object when the socket is created with a refrence to the socket.</li>
<li>
<code>host</code> <strong><em>optional</em></strong> is the host on which the TCP or TLS socket resides.  This will default to  <code>ipc.config.networkHost</code> if not specified.</li>
<li>
<code>port</code> <strong><em>optional</em></strong>
</li>
<li>
<code>callback</code> <strong><em>optional</em></strong> this is the function to execute when the socket has been created.</li>
</ol><p><strong>examples</strong> arguments can be ommitted solong as they are still in order.<br>
So while the default is : (id,host,port,callback), the following examples will still work because they are still in order (id,port,callback) or (id,host,callback) or (id,port) etc.</p>

<pre><code>ipc.connectToNet('world');
</code></pre>

<p>or using just an id and a callback</p>

<pre><code>ipc.connectToNet(
    'world',
    function(){
        ...
    }
);
</code></pre>

<p>or explicitly setting the host and path</p>

<pre><code>ipc.connectToNet(
    'world',
    'myapp.com',serve(path,callback)
    3435
);
</code></pre>

<p>or only explicitly setting port and callback</p>

<pre><code>ipc.connectToNet(
    'world',
    3435,
    function(){
        ...
    }
);
</code></pre>

<hr><h5>
<a name="serve" class="anchor" href="#serve"><span class="octicon octicon-link"></span></a>serve</h5>

<p><code>ipc.serve(path,callback);</code>  </p>

<p>Used to create local Unix Socket Server to which Clients can bind. The server can <code>emit</code> events to specific Client Sockets, or <code>broadcast</code> events to all known Client Sockets.   </p>

<ol>
<li>
<code>path</code> <strong><em>optional</em></strong> This is the Unix Domain Socket path to bind to. If not supplied, it will default to : ipc.config.socketRoot + ipc.config.appspace + ipc.config.id;</li>
<li>
<p><code>callback</code> <strong><em>optional</em></strong> This is a function to be called after the Server has started. This can also be done by binding an event to the start event as follows :</p>

<p>ipc.server.on(
    'start',
    callback
);</p>
</li>
</ol><p><strong><em>examples</em></strong></p>

<pre><code>ipc.serve();
</code></pre>

<p>or specifying callback</p>

<pre><code>ipc.serve(
    function(){...}
);
</code></pre>

<p>or specify path</p>

<pre><code>ipc.serve(
    '/tmp/myapp.myservice'
);
</code></pre>

<p>or specifying everything</p>

<pre><code>ipc.serve(
    '/tmp/myapp.myservice',
    function(){...}
);
</code></pre>

<hr><h5>
<a name="servenet" class="anchor" href="#servenet"><span class="octicon octicon-link"></span></a>serveNet</h5>

<p>coming soon ...
For TCP, TLS &amp; UDP servers this is most likely going to be local host or 0.0.0.0 unless you have something like <a href="https://github.com/RIAEvangelist/node-http-server">node-http-server</a> installed to run subdomains for you.</p>

<hr><h3>
<a name="basic-examples" class="anchor" href="#basic-examples"><span class="octicon octicon-link"></span></a>Basic Examples</h3>

<h4>
<a name="server-for-unix-sockets--tcp-sockets" class="anchor" href="#server-for-unix-sockets--tcp-sockets"><span class="octicon octicon-link"></span></a>Server for Unix Sockets &amp; TCP Sockets</h4>

<p>The server is the process keeping a socket for IPC open. Multiple sockets can connect to this server and talk to it. It can also broadcast to all clients or emit to a specific client. This is the most basic example which will work for both local Unix Sockets and local or remote network TCP Sockets.</p>

<pre><code>var ipc=require('node-ipc');

ipc.config.id   = 'world';
ipc.config.retry= 1500;

ipc.serve(
    function(){
        ipc.server.on(
            'message',
            function(data,socket){
                ipc.log('got a message : '.debug, data);
                socket.emit(
                    'message',
                    data+' world!'
                );
            }
        );
    }
);

ipc.server.start();
</code></pre>

<h4>
<a name="client-for-unix-sockets--tcp-sockets" class="anchor" href="#client-for-unix-sockets--tcp-sockets"><span class="octicon octicon-link"></span></a>Client for Unix Sockets &amp; TCP Sockets</h4>

<p>The client connects to the servers socket for Inter Process Communication. The socket will recieve events emitted to it specifically as well as events which are broadcast out on the socket by the server. This is the most basic example which will work for both local Unix Sockets and local or remote network TCP Sockets.</p>

<pre><code>var ipc=require('../../../node-ipc');

ipc.config.id   = 'hello';
ipc.config.retry= 1500;

ipc.connectTo(
    'world',
    function(){
        ipc.of.world.on(
            'connect',
            function(){
                ipc.log('## connected to world ##'.rainbow, ipc.config.delay);
                ipc.of.world.emit(
                    'message',
                    'hello'
                )
            }
        );
        ipc.of.world.on(
            'disconnect',
            function(){
                ipc.log('disconnected from world'.notice);
            }
        );
        ipc.of.world.on(
            'message',
            function(data){
                ipc.log('got a message from world : '.debug, data);
            }
        );
    }
);
</code></pre>

<h4>
<a name="server--client-for-udp-sockets" class="anchor" href="#server--client-for-udp-sockets"><span class="octicon octicon-link"></span></a>Server &amp; Client for UDP Sockets</h4>

<p>UDP Sockets are different than Unix &amp; TCP Sockets because they must be bound to a unique port on their machine to recieve messages. For example, A TCP or Unix Socket client could just connect to a seperate TCP or Unix Socket sever. That client could then exchange, both send and recive, data on the servers port or location. UDP Sockets can not do this. They must bind to a port to recieve or send data.  </p>

<p>This means a UDP Client and Server are the same thing because inorder to recieve data, a UDP Socket must have its own port to recieve data on, and only one process can use this port at a time. It also means that inorder to <code>emit</code> or <code>broadcast</code> data the UDP server will need to know the host and port of the Socket it intends to broadcast the data to.</p>

<p>This is the most basic example which will work for both local Unix Sockets and local or remote network TCP Sockets.</p>

<h5>
<a name="udp-server-1---world" class="anchor" href="#udp-server-1---world"><span class="octicon octicon-link"></span></a>UDP Server 1 - "World"</h5>

<pre><code>var ipc=require('../../../node-ipc');

ipc.config.id   = 'world';
ipc.config.retry= 1500;

ipc.serveNet(
    'udp4',
    function(){
        console.log(123);
        ipc.server.on(
            'message',
            function(data,socket){
                ipc.log('got a message from '.debug, data.from.variable ,' : '.debug, data.message.variable);
                ipc.server.emit(
                    socket,
                    'message',
                    {
                        from    : ipc.config.id,
                        message : data.message+' world!'
                    }
                );
            }
        );

        console.log(ipc.server);
    }
);

ipc.server.define.listen.message='This event type listens for message strings as value of data key.';

ipc.server.start();
</code></pre>

<h5>
<a name="udp-server-2---hello" class="anchor" href="#udp-server-2---hello"><span class="octicon octicon-link"></span></a>UDP Server 2 - "Hello"</h5>

<p><em>note</em> we set the port here to 8001 because the world server is already using the default ipc.config.networkPort of 8000. So we can not bind to 8000 while world is using it.</p>

<pre><code>ipc.config.id   = 'hello';
ipc.config.retry= 1500;

ipc.serveNet(
    8001,
    'udp4',
    function(){
        ipc.server.on(
            'message',
            function(data){
                ipc.log('got Data');
                ipc.log('got a message from '.debug, data.from.variable ,' : '.debug, data.message.variable);
            }
        );
        ipc.server.emit(
            {
                address : 'localhost',
                port    : ipc.config.networkPort
            },
            'message',
            {
                from    : ipc.config.id,
                message : 'Hello'
            }
        );
    }
);

ipc.server.define.listen.message='This event type listens for message strings as value of data key.';

ipc.server.start();
</code></pre>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Node-ipc maintained by <a href="https://github.com/RIAEvangelist">RIAEvangelist</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
